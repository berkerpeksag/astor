# -*- coding: utf-8 -*-
"""
Part of the astor library for Python AST manipulation.

License: 3-clause BSD

Copyright (c) 2008      Armin Ronacher
Copyright (c) 2012-2017 Patrick Maupin
Copyright (c) 2013-2017 Berker Peksag

This module converts an AST into Python source code.

Before being version-controlled as part of astor,
this code came from here (in 2012):

    https://gist.github.com/1250562

This now supports later versions of Python, and generates
better looking output by removing extraneous parentheses and
wrapping long lines.

The main entry point is the `SourceGenerator.to_source` class
method.  For convenience and legacy compatibility, this may
also be accessed via the module `to_source` variable.

"""

import ast
import sys

from .op_util import get_op_symbol, get_op_precedence, Precedence
from .prettifier import Formatter


###################################################################
#               Main class
###################################################################

class SourceGenerator(dict):
    """ This class is able to transform a well formed syntax tree
        into Python sourcecode.

        For more details,look at the `to_source` function.

        The reason this subclasses a dictionary is so that the dict
        may be used to memoize the AST class -> visitor mapping.
    """

    # Goofy from __future__ string handling for 2.7
    using_unicode_literals = False

    ###################################################################
    #               Main interface
    ###################################################################

    @classmethod
    def to_source(cls, node, indent_with=' ' * 4, add_line_information=False,
                  formatter=Formatter):
        """This function can convert a node tree back into python sourcecode.
        This is useful for debugging purposes, especially if you're dealing
        with custom ASTs not generated by python itself.

        It could be that the sourcecode is evaluable when the AST itself is
        not compilable / evaluable.  The reason for this is that the AST
        contains some more data than regular sourcecode does, which is
        dropped during conversion.

        Each level of indentation is replaced with `indent_with`.  Per
        default this parameter is equal to four spaces as suggested by
        PEP 8, but it might be adjusted to match the application's styleguide.

        If `add_line_information` is set to `True` comments for the line
        numbers of the nodes are added to the output.  This can be used
        to spot wrong line number information of statement nodes.

        The `formatter` parameter should be an object with an `s_lit()`
        method that will build a representation of a literal string,
        and an `out_format()` method that will perform any required
        pretty-printing output transformations on the object.
        """
        self = cls(indent_with, add_line_information, formatter)
        self.visit(node)
        self.out_format(self.statements)
        return ''.join(self.result)

    ###################################################################
    #               Top-level tree constructs
    ###################################################################

    # Normal entry path
    def visit_Module(self, node):
        self.write(node.body)

    # Code compiled with 'eval' or 'single'
    visit_Interactive = visit_Module
    visit_Expression = visit_Module

    ###################################################################
    #                      Statements
    ###################################################################

    def visit_AnnAssign(self, node):
        """ Annotated assignment """
        set_precedence(node, node.target, node.annotation)
        set_precedence(Precedence.Comma, node.value)
        need_parens = isinstance(node.target, ast.Name) and not node.simple
        target_str = ('(', node.target, ')') if need_parens else node.target
        self.statement(node, target_str, ': ', node.annotation,
                       conditional(' = ', node.value))

    def visit_Assert(self, node):
        set_precedence(node, node.test, node.msg)
        self.statement(node, 'assert ', node.test, conditional(', ', node.msg))

    def visit_Assign(self, node):
        set_precedence(node, node.value, *node.targets)
        self.statement(node, ((target, ' = ') for target in node.targets),
                       node.value)

    # introduced in Python 3.5
    def visit_AsyncFor(self, node):
        self.visit_For(node, keyword='async for ')

    # introduced in Python 3.5
    def visit_AsyncFunctionDef(self, node):
        self.visit_FunctionDef(node, keyword='async def ')

    # new for Python 3.5
    def visit_AsyncWith(self, node):
        self.visit_With(node, keyword='async with ')

    def visit_AugAssign(self, node):
        set_precedence(node, node.value, node.target)
        self.statement(node, node.target, get_op_symbol(node.op, ' %s= '),
                       node.value)

    def visit_Break(self, node):
        self.statement(node, 'break')

    def visit_Continue(self, node):
        self.statement(node, 'continue')

    def visit_ClassDef(self, node):
        paren_or_comma = CommaSeparator()
        paren_or_comma.value = '('

        def end_list():
            """ Don't access paren_or_comma until we're done """
            yield ':' if paren_or_comma.value == '(' else '):'

        keywords = self.get_keywords(node)
        starargs = self.get_starargs(node)
        kwargs = self.get_kwargs(node)

        self.decorators(node, 2)
        self.statement(node, 'class ', node.name,
                       ((paren_or_comma, base) for base in node.bases),
                       ((paren_or_comma,
                        (keyword.arg, '=') if keyword.arg else '**',
                        keyword.value) for keyword in keywords),
                       conditional(paren_or_comma, '*', starargs),
                       conditional(paren_or_comma, '**', kwargs),
                       end_list(), node.body)
        if not self.indentation:
            self.newline(extra=2)

    def visit_Delete(self, node):
        self.statement(node, 'del ', comma_group(node.targets))

    def visit_Expr(self, node):
        """ Expression not in an assignment.
            Usually a call or a docstring.
        """
        set_precedence(node, node.value)
        self.statement(node, node.value)

    def visit_ExceptHandler(self, node):
        type_ = conditional(' ', node.type)
        type_ = (type_, conditional(' as ', node.name)) if type_ else type_
        self.statement(node, 'except', type_, ':', node.body)

    def visit_Exec(self, node):
        dicts = node.globals, node.locals
        dicts = dicts[::-1] if dicts[0] is None else dicts
        self.statement(node, 'exec ', node.body, conditional(' in ', dicts[0]),
                       conditional(', ', dicts[1]))

    def visit_For(self, node, keyword='for '):
        set_precedence(node, node.target)
        self.statement(node, keyword, node.target, ' in ', node.iter, ':',
                       node.body, else_body(node))

    def visit_FunctionDef(self, node, keyword='def '):
        self.decorators(node, 1 if self.indentation else 2)
        returns = self.get_returns(node)
        returns = ('->', returns, ':') if returns else ':'
        self.statement(node, keyword, node.name, '(', node.args, ')',
                       returns, node.body)
        if not self.indentation:
            self.newline(extra=2)

    def visit_Global(self, node):
        self.statement(node, 'global ', node.names[0],
                       ((', ', x) for x in node.names[1:]))

    def visit_If(self, node):
        set_precedence(node, node.test)
        self.statement(node, 'if ', node.test, ':', node.body,
                       else_body(node))

    def visit_Import(self, node):
        self.statement(node, 'import ', comma_group(node.names))

    def visit_ImportFrom(self, node):
        self.statement(node, 'from ', node.level * '.',
                       conditional(node.module), ' import ',
                       comma_group(node.names))

        # Goofy stuff for Python 2.7 _pyio module
        if node.module == '__future__' and 'unicode_literals' in (
                x.name for x in node.names):
            self.using_unicode_literals = True

    def visit_Nonlocal(self, node):
        self.statement(node, 'nonlocal ', node.names[0],
                       ((', ', x) for x in node.names[1:]))

    def visit_Pass(self, node):
        self.statement(node, 'pass')

    def visit_Print(self, node):
        # python 2.6 only
        self.statement(node, 'print ')
        values = node.values
        if node.dest is not None:
            self.write(' >> ')
            values = [node.dest] + values
        self.write(comma_group(values, not node.nl))

    def visit_Raise(self, node):
        # Python 2.6 / 3.0 differences here
        exc = conditional(' ', self.get_exc(node))
        exc = exc and (exc, conditional(' from ', node.cause))
        if not exc:
            exc = conditional(' ', self.get_type(node))
            if exc:
                set_precedence(node, node.inst)
                exc = (exc, conditional(', ', node.inst),
                       conditional(', ', node.tback))
        self.statement(node, 'raise', exc)

    def visit_Return(self, node):
        set_precedence(node, node.value)
        self.statement(node, 'return', conditional(' ', node.value))

    # new for Python 3.3
    def visit_Try(self, node):
        self.statement(node, 'try:', node.body, iter(node.handlers),
                       else_body(node))
        if node.finalbody:
            self.statement(node, 'finally:', node.finalbody)

    def visit_TryExcept(self, node):
        self.statement(node, 'try:', node.body, iter(node.handlers),
                       else_body(node))

    def visit_TryFinally(self, node):
        self.statement(node, 'try:', node.body)
        self.statement(node, 'finally:', node.finalbody)

    def visit_While(self, node):
        set_precedence(node, node.test)
        self.statement(node, 'while ', node.test, ':', node.body,
                       else_body(node))

    def visit_With(self, node, keyword='with ', hasattr=hasattr):
        """ Pythons before 3.3 used a context_expr; pythons after that use
            a list of contexts items.
        """
        old_way = hasattr(node, 'context_expr')
        params = ((node.context_expr, conditional(' as ', node.optional_vars))
                  if old_way else comma_group(node.items))
        self.statement(node, keyword, params, ':', node.body)

    ###################################################################
    #               Expression operators
    ###################################################################

    def visit_Attribute(self, node):
        self.write(node.value, '.', node.attr)

    def visit_BinOp(self, node):
        op, left, right = node.op, node.left, node.right
        with self.delimit(node, op) as delimiters:
            ispow = isinstance(op, ast.Pow)
            p = delimiters.p
            set_precedence((Precedence.Pow + 1) if ispow else p, left)
            set_precedence(Precedence.PowRHS if ispow else (p + 1), right)
            self.write(left, get_op_symbol(op, ' %s '), right)

    def visit_BoolOp(self, node):
        with self.delimit(node, node.op) as delimiters:
            set_precedence(delimiters.p + 1, *node.values)
            op = get_op_symbol(node.op, ' %s ')
            self.write(((op, value) if idx else value)
                       for idx, value in enumerate(node.values))

    def visit_Compare(self, node):
        with self.delimit(node, node.ops[0]) as delimiters:
            set_precedence(delimiters.p + 1, node.left, *node.comparators)
            self.write(node.left, ((get_op_symbol(op, ' %s '), right)
                       for op, right in zip(node.ops, node.comparators)))

    def visit_ExtSlice(self, node):
        dims = node.dims
        set_precedence(node, *dims)
        self.write(comma_group(dims, len(dims) == 1))

    def visit_IfExp(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p + 1, node.body, node.test)
            set_precedence(delimiters.p, node.orelse)
            self.write(node.body, ' if ', node.test, ' else ', node.orelse)

    def visit_Index(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.value)
            self.write(node.value)

    def visit_Slice(self, node):
        set_precedence(node, node.lower, node.upper, node.step)
        self.write(conditional(node.lower), ':', conditional(node.upper),
                   get_step(node))

    def visit_Subscript(self, node):
        set_precedence(node, node.slice)
        self.write(node.value, '[', node.slice, ']')

    def visit_UnaryOp(self, node):
        with self.delimit(node, node.op) as delimiters:
            set_precedence(delimiters.p, node.operand)
            # In Python 2.x, a unary negative of a literal
            # number is merged into the number itself.  This
            # bit of ugliness means it is useful to know
            # what the parent operation was...
            node.operand._p_op = node.op
            sym = get_op_symbol(node.op)
            # Need a space between alpha operand and a number
            spacer = conditional(' ' if sym.isalpha() else None)
            self.write(sym, spacer, node.operand)

    ###################################################################
    #               Function calls
    ###################################################################

    def visit_Call(self, node):
        write_comma = CommaSeparator()

        args = node.args
        keywords = node.keywords
        starargs = self.get_starargs(node)
        kwargs = self.get_kwargs(node)
        numargs = len(args) + len(keywords)
        numargs += starargs is not None
        numargs += kwargs is not None
        p = Precedence.Comma if numargs > 1 else Precedence.call_one_arg
        set_precedence(p, *args)
        set_precedence(Precedence.Comma, *(x.value for x in keywords))

        self.write(node.func, '(', ((write_comma, arg) for arg in args),
                   # a keyword.arg of None indicates dictionary unpacking
                   # (Python >= 3.5)
                   ((write_comma,
                    (keyword.arg, '=') if keyword.arg else '**',
                     keyword.value) for keyword in keywords),
                   # 3.5 no longer has these
                   conditional(write_comma, '*', starargs),
                   conditional(write_comma, '**', kwargs), ')')

    ###################################################################
    #               Expression keywords
    ###################################################################

    # new for Python 3.5
    def visit_Await(self, node):
        with self.delimit(node):
            self.write('await ', node.value)

    def visit_Lambda(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.body)
            self.write('lambda ', node.args, ': ', node.body)

    def visit_Yield(self, node):
        with self.delimit(node):
            set_precedence(get_op_precedence(node) + 1, node.value)
            self.write('yield', conditional(' ', node.value))

    # new for Python 3.3
    def visit_YieldFrom(self, node):
        with self.delimit(node):
            self.write('yield from ', node.value)

    ###################################################################
    #               Container types
    ###################################################################

    def visit_Dict(self, node):
        set_precedence(Precedence.Comma, *node.values)
        with self.delimit('{}'):
            self.write((', ' if idx else (), (key, ': ') if key else '**',
                       value) for idx, (key, value)
                       in enumerate(zip(node.keys, node.values)))

    def visit_List(self, node):
        with self.delimit('[]'):
            self.write(comma_group(node.elts))

    def visit_Set(self, node):
        with self.delimit('{}'):
            self.write(comma_group(node.elts))

    def visit_Tuple(self, node):
        with self.delimit(node) as delimiters:
            # Two things are special about tuples:
            #   1) We cannot discard the enclosing parentheses if empty
            #   2) We need the trailing comma if only one item
            elts = node.elts
            delimiters.discard = delimiters.discard and elts
            self.write(comma_group(elts, len(elts) == 1))

    ###################################################################
    #               Leaf operands
    ###################################################################

    def visit_Bytes(self, node):
        self.write(self.s_lit(node.s, 'b', None))

    def visit_Ellipsis(self, node):
        self.write('...')

    def visit_JoinedStr(self, node):
        # Flush any pending newlines, because we're about
        # to severely abuse the result list.
        self.write('')

        # Handle new f-strings.  This is a bit complicated, because
        # the tree can contain subnodes that recurse back to JoinedStr
        # subnodes...

        def recurse(node):
            for value in node.values:
                if isinstance(value, ast.Str):
                    self.write(value.s)
                elif isinstance(value, ast.FormattedValue):
                    with self.delimit('{}'):
                        self.write(value.value)
                        if value.conversion != -1:
                            self.write('!%s' % chr(value.conversion))
                        if value.format_spec is not None:
                            self.write(':')
                            recurse(value.format_spec)
                else:
                    kind = type(value).__name__
                    assert False, 'Invalid node %s inside JoinedStr' % kind

        result = self.statements[-1]
        index = len(result)
        recurse(node)
        mylist = result[index:]
        del result[index:]

        self.write(self.s_lit(''.join(mylist), 'f', mylist))

    def visit_Name(self, node):
        self.write(node.id)

    def visit_NameConstant(self, node, str=str):
        self.write(str(node.value))

    def visit_Num(self, node,
                  # constants
                  new=sys.version_info >= (3, 0),
                  repr=repr):
        with self.delimit(node) as delimiters:
            s = repr(node.n)

            # Deal with infinities -- if detected, we can
            # generate them with 1e1000.
            signed = s.startswith('-')
            if s[signed].isalpha():
                im = s[-1] == 'j' and 'j' or ''
                assert s[signed:signed + 3] == 'inf', s
                s = '%s1e1000%s' % ('-' if signed else '', im)
            self.write(s)

            # The Python 2.x compiler merges a unary minus
            # with a number.  This is a premature optimization
            # that we deal with here...
            if not new and delimiters.discard:
                if signed:
                    pow_lhs = Precedence.Pow + 1
                    delimiters.discard = delimiters.pp != pow_lhs
                else:
                    op = self.get__p_op(node)
                    delimiters.discard = not isinstance(op, ast.USub)

    def visit_Repr(self, node):
        # python 2.6 only
        with self.delimit('``'):
            self.write(node.value)

    def visit_Str(self, node, repr=repr):
        is_bytes = self.using_unicode_literals and isinstance(node.s, bytes)
        self.write(self.s_lit(node.s, 'b' if is_bytes else '', None))

    ###################################################################
    #               Comprehensions and generators
    ###################################################################

    def visit_DictComp(self, node):
        with self.delimit('{}'):
            self.write(node.key, ': ', node.value, *node.generators)

    def visit_GeneratorExp(self, node):
        with self.delimit(node) as delimiters:
            if delimiters.pp == Precedence.call_one_arg:
                delimiters.discard = True
            set_precedence(Precedence.Comma, node.elt)
            self.write(node.elt, *node.generators)

    def visit_ListComp(self, node):
        with self.delimit('[]'):
            self.write(node.elt, *node.generators)

    def visit_SetComp(self, node):
        with self.delimit('{}'):
            self.write(node.elt, node.generators)

    ###################################################################
    #               Helper nodes
    ###################################################################

    def visit_alias(self, node):
        self.write(node.name, conditional(' as ', node.asname))

    def visit_arg(self, node):
        self.write(node.arg, conditional(': ', node.annotation))

    def visit_arguments(self, node):
        write = self.write
        write_comma = CommaSeparator()

        def loop_args(args, defaults):
            set_precedence(Precedence.Comma, defaults)
            padding = [None] * (len(args) - len(defaults))
            write((write_comma,
                  (arg if default is None else (arg, '=', default)))
                  for arg, default in zip(args, padding + defaults))

        loop_args(node.args, node.defaults)
        write(conditional(write_comma, '*', node.vararg))

        kwonlyargs = self.get_kwonlyargs(node)
        if kwonlyargs:
            if node.vararg is None:
                write(write_comma, '*')
            loop_args(kwonlyargs, node.kw_defaults)
        write(conditional(write_comma, '**', node.kwarg))

    def visit_comprehension(self, node):
        set_precedence(node, node.iter, *node.ifs)
        set_precedence(Precedence.comprehension_target, node.target)
        keyword = ' async for ' if self.get_is_async(node) else ' for '
        self.write(keyword, node.target, ' in ', node.iter,
                   ((' if ', if_) for if_ in node.ifs))

    def visit_Starred(self, node):
        self.write('*', node.value)

    # new for Python 3.3
    def visit_withitem(self, node):
        self.write(node.context_expr, conditional(' as ', node.optional_vars))

    ###################################################################
    #               non-AST node visitors
    ###################################################################

    def visit_CommaSeparator(self, node):
        """ Helps us print a heterogenous comma-separated list
        """
        self.write(node.value)
        node.value = (', ')

    def visit_LineFeed(self, node):
        """ Visit a linefeed to insert a newline
        """
        self.newline()

    def visit_str(self, item):
        """ At the bottom, everything is a (real) string.  This is not
            the AST Str type; it's the Python interpreter's string.  This
            is where we store things in the result we are building.
        """
        statements = self.statements
        if self.new_lines:
            statements.extend([['\n' * self.new_lines],
                              [self.indent_with * self.indentation]])
            self.new_lines = 0
        statements[-1].append(item)

    visit_StringLiteral = visit_str

    def visit_function(self, node):
        """ When we visit a callable, just call it to let it
            do it's thing.
        """
        node()

    visit_method = visit_function
    visit_instancemethod = visit_function

    ###################################################################
    #               Methods called by visitors
    ###################################################################

    def decorators(self, node, extra):
        """ Add decorators in front of a class or function def
        """
        self.newline(extra=extra)
        for decorator in node.decorator_list:
            self.statement(decorator, '@', decorator)

    def delimit(self, *args):
        """ Wrapper to make instantiation of Delimit class a bit cleaner
        """
        return Delimit(self, args)

    def newline(self, extra=0):
        """ Output new lines before the next token
        """
        self.new_lines = max(self.new_lines, 1 + extra)

    def statement(self, node, *params):
        """ A statement starts at the beginning of a line,
            and may have associated line number information
        """
        self.newline()
        if self.add_line_information:
            self.write('# line: %s' % node.lineno)
            self.new_lines = 1
        self.write(*params)

    def __getattr__(self, name, defaults=dict(keywords=(),
                    _pp=Precedence.highest).get):
        """ Get an attribute of the node.
            like dict.get (returns None if doesn't exist)
        """
        if not name.startswith('get_'):
            raise AttributeError
        geta = getattr
        shortname = name[4:]
        default = defaults(shortname)

        def getter(node):
            return geta(node, shortname, default)

        setattr(self, name, getter)
        return getter

    def __missing__(self, nodetype):
        """ Cache type -> visitor relationship
        """
        method = 'visit_' + nodetype.__name__
        visitor = getattr(self, method, None)
        if visitor is None:
            msg = 'No defined handler for node of type %s'
            raise AttributeError(msg % method[6:])
        self[nodetype] = visitor
        return visitor

    def __init__(self, indent_with, add_line_information=False,
                 formatter=Formatter):
        """ Initialize the instance, and use a closure for
            writes for faster tree traversal.
        """
        self.indent_with = indent_with
        self.add_line_information = add_line_information
        formatter = formatter() if callable(formatter) else formatter
        self.s_lit = formatter.s_lit
        self.out_format = formatter.out_format

        self.statements = []
        self.indentation = -1  # Current indentation level
        self.new_lines = 1  # Number of lines to insert before next code

        type_ = type

        def write(*args):
            """ Main dispatcher
            """
            item = None
            for item in args:
                self[type_(item)](item)
            return item

        def write_iter(args):
            """ Like write() but a single iterable parameter,
                rather than *args.
            """
            item = None
            for item in args:
                self[type_(item)](item)
            return item

        def write_body(statements):
            """ This is what we do when we encounter
                a list in the tree rather than an instance
                of ast.AST.
            """
            self.indentation += 1
            write_iter(statements)
            self.indentation -= 1

        self.write = write

        # Insure that we handle lists, tuples, generators, etc. properly
        self[tuple] = write_iter
        self[type(x for x in [])] = write_iter
        self[type(iter([]))] = write_iter
        self[type([])] = write_body

    @property
    def result(self):
        """ Return a flattened result list.

            Scrubs off prepended linefeeds.
        """
        statements = self.statements
        statements.append(['\n'])
        if set(statements[0][0]) == set('\n'):
            statements[0][0] = ''
        return [s for lst in statements for s in lst]

    def visit(self, node):
        """ Visit a node tree and generate results.
        """
        self.write(node)


###################################################################
#               Convenience function
###################################################################

to_source = SourceGenerator.to_source


###################################################################
#               Utility functions, classes, and instances
###################################################################


class LineFeed(object):
    """ A class of a special object that causes a linefeed
        to be inserted in the output.
    """


linefeed = LineFeed()


def set_precedence(value, *nodes):
    """ Set the precedence (of the parent) into the children.

        The purpose of setting the precedence is to be able
        to determine if parentheses are needed at any level
        of an expression.
    """
    if isinstance(value, ast.AST):
        value = get_op_precedence(value)
    for node in nodes:
        if isinstance(node, ast.AST):
            node._pp = value
        elif isinstance(node, list):
            set_precedence(value, *node)
        else:
            assert node is None, node


def conditional(*params):
    """ If the last param evaluates to None, just return
        an empty tuple
    """
    return params if params[-1] is not None else ()


def comma_group(items, trailing=False):
    """ Print a group of 0 or more items, with commas between,
        and an optional trailing comma.
    """
    set_precedence(Precedence.Comma, *items)
    yield (((', ', item) if idx else item)
           for idx, item in enumerate(items))
    if trailing:
        yield ','


def else_body(node):
    """ Perform the ugly logic to coalesce multiple ifs
        together with elif.
    """
    orelse = node.orelse
    while orelse:
        if len(orelse) == 1 and type(orelse[0]) is ast.If is type(node):
            node = orelse[0]
            set_precedence(node, node.test)
            yield linefeed, 'elif ', node.test, ':', node.body
            orelse = node.orelse
        else:
            yield linefeed, 'else:', orelse
            return


def get_step(node):
    """ Perform the ugly logic to get the step for a slice.
        If there is a step, but it is None, we don't display
        the None.
    """
    if node.step is not None:
        yield ':'
        if (isinstance(node.step, ast.Name) and
                node.step.id == 'None'):
            pass
        yield node.step


class CommaSeparator(object):
    value = ()


class Delimit(object):
    """A context manager that can add enclosing
       delimiters around the output of a
       SourceGenerator method.  By default, the
       parentheses are added, but the enclosed code
       may set discard=True to get rid of them,
       e.g. if it turns out that parentheses are not
       needed around an expression.
    """

    discard = False

    def __init__(self, tree, args,
                 # Constants
                 AST=ast.AST, isinstance=isinstance, len=len):
        """ use write instead of using result directly
            for initial data, because it may flush
            preceding linefeed data into result.
        """
        delimiters = '()'
        node = None
        op = None
        for arg in args:
            if isinstance(arg, AST):
                if node is None:
                    node = arg
                else:
                    op = arg
            else:
                delimiters = arg
        tree.write(delimiters[0])
        result = self.result = tree.statements[-1]
        self.index = len(result)
        self.closing = delimiters[1]
        if node is not None:
            self.p = p = get_op_precedence(op or node)
            self.pp = pp = tree.get__pp(node)
            self.discard = p >= pp

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        result = self.result
        start = self.index - 1
        if self.discard:
            del result[start]
        else:
            result.append(self.closing)
