# -*- coding: utf-8 -*-
"""
Part of the astor library for Python AST manipulation.

License: 3-clause BSD

Copyright (c) 2008      Armin Ronacher
Copyright (c) 2012-2017 Patrick Maupin
Copyright (c) 2013-2017 Berker Peksag

This module converts an AST into Python source code.

Before being version-controlled as part of astor,
this code came from here (in 2012):

    https://gist.github.com/1250562

"""

import ast
import inspect
import math

from .op_util import get_op_symbol, get_op_precedence, Precedence
from .node_util import ExplicitNodeVisitor
# from .string_repr import pretty_string
from .source_repr import pretty_source


def escape_string(s: str, quote_char: str = '"', is_docstring: bool = False) -> str:
    """
    Comprehensively escape a Python string, handling all special characters.
    Preserves newlines in docstrings.

    Args:
        s: The input string to escape
        quote_char: The quote character to use (either ' or ")
        is_docstring: Whether this string is a docstring

    Returns:
        Properly escaped string that can be safely represented in Python code
    """
    result = []
    i = 0
    length = len(s)

    # Common escape sequences
    escape_dict = {
        '\r': '\\r',
        '\t': '\\t',
        '\f': '\\f',
        '\b': '\\b',
        '\a': '\\a',
        '\v': '\\v',
        '\\': '\\\\',
        '\0': '\\0',
    }

    # Add \n to escape_dict only if this is not a docstring
    if not is_docstring:
        escape_dict['\n'] = '\\n'

    while i < length:
        char = s[i]

        # Handle quotes
        if char == quote_char and not is_docstring:  # TODO: added doc string check
            result.append('\\' + char)
        # Handle predefined escape sequences
        elif char in escape_dict:
            result.append(escape_dict[char])
        # Handle newlines in docstrings
        elif char == '\n' and is_docstring:
            result.append(char)
        # Handle non-printable ASCII characters
        elif ord(char) < 32 or ord(char) == 127:
            if char != '\n' or not is_docstring:  # Don't escape newline in docstrings
                result.append(f'\\x{ord(char):02x}')
            else:
                result.append(char)
        # Handle non-ASCII characters
        elif ord(char) > 127:
            # Use short form if possible
            if ord(char) <= 0xFFFF:
                result.append(f'\\u{ord(char):04x}')
            else:
                result.append(f'\\U{ord(char):08x}')
        # Handle already escaped sequences
        elif char == '\\' and i + 1 < length:
            next_char = s[i + 1]
            chars = {'n', 'r', 't', '0', '1', 'x', 'u', 'U', '\\', '"', "'"}
            #if is_docstring:
            #    chars -= {'"', "'"}
            if next_char in chars:
                result.append('\\\\' + next_char)
                i += 1
            else:
                result.append(char)
        else:
            result.append(char)
        i += 1

    return ''.join(result)

def pretty_string(string: str, embedded: bool = False, current_line: str = '', is_docstring: bool = False) -> str:
    """
    Format a string with proper quotes and comprehensive escape handling.

    Args:
        string: The input string to format
        embedded: Whether the string is embedded in an expression
        current_line: The current line being processed
        is_docstring: Whether this string is a docstring

    Returns:
        Properly formatted string with appropriate quotes and escaping
    """
    # Handle empty strings
    if not string:
        # TODO: Add this for this
        return '""' if '"' in current_line else "''"

    # Check if this is a multiline string
    lines = string.splitlines(keepends=True)
    if len(lines) > 1 or is_docstring:
        # For multiline strings and docstrings, use triple quotes and escape any embedded triple quotes
        escaped = escape_string(string, '"', is_docstring=True)
        if '"""' in escaped:
            escaped = escaped.replace('"""', '\\"\\"\\"')
        return f'"""{escaped}"""'

    # For single line strings, choose quotes based on content
    quote_char = "'" if "'" not in string or '"""' in string else '"'
    return quote_char + escape_string(string, quote_char, is_docstring=False) + quote_char


def to_source(node, indent_with=' ' * 4, add_line_information=False,
              pretty_string=pretty_string, pretty_source=pretty_source,
              source_generator_class=None):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.

    If `add_line_information` is set to `True` comments for the line numbers
    of the nodes are added to the output.  This can be used to spot wrong line
    number information of statement nodes.

    `source_generator_class` defaults to `SourceGenerator`, and specifies the
    class that will be instantiated and used to generate the source code.

    """
    if source_generator_class is None:
        source_generator_class = SourceGenerator
    elif not inspect.isclass(source_generator_class):
        raise TypeError('source_generator_class should be a class')
    elif not issubclass(source_generator_class, SourceGenerator):
        raise TypeError('source_generator_class should be a subclass of SourceGenerator')
    generator = source_generator_class(
        indent_with, add_line_information, pretty_string)
    generator.visit(node)
    generator.result.append('\n')
    if set(generator.result[0]) == set('\n'):
        generator.result[0] = ''
    return pretty_source(generator.result)


def precedence_setter(AST=ast.AST, get_op_precedence=get_op_precedence,
                      isinstance=isinstance, list=list):
    """ This only uses a closure for performance reasons,
        to reduce the number of attribute lookups.  (set_precedence
        is called a lot of times.)
    """

    def set_precedence(value, *nodes):
        """Set the precedence (of the parent) into the children.
        """
        if isinstance(value, AST):
            value = get_op_precedence(value)
        for node in nodes:
            if isinstance(node, AST):
                node._pp = value
            elif isinstance(node, list):
                set_precedence(value, *node)
            else:
                assert node is None, node

    return set_precedence


set_precedence = precedence_setter()


class Delimit(object):
    """A context manager that can add enclosing
       delimiters around the output of a
       SourceGenerator method.  By default, the
       parentheses are added, but the enclosed code
       may set discard=True to get rid of them.
    """

    discard = False

    def __init__(self, tree, *args):
        """ use write instead of using result directly
            for initial data, because it may flush
            preceding data into result.
        """
        delimiters = '()'
        node = None
        op = None
        for arg in args:
            if isinstance(arg, ast.AST):
                if node is None:
                    node = arg
                else:
                    op = arg
            else:
                delimiters = arg
        tree.write(delimiters[0])
        result = self.result = tree.result
        self.index = len(result)
        self.closing = delimiters[1]
        if node is not None:
            self.p = p = get_op_precedence(op or node)
            self.pp = pp = tree.get__pp(node)
            self.discard = p >= pp

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        result = self.result
        start = self.index - 1
        if self.discard:
            result[start] = ''
        else:
            result.append(self.closing)


class SourceGenerator(ExplicitNodeVisitor):
    """This visitor is able to transform a well formed syntax tree into Python
    sourcecode.

    For more details have a look at the docstring of the `to_source`
    function.

    """

    def __init__(self, indent_with, add_line_information=False,
                 pretty_string=pretty_string,
                 # constants
                 len=len, isinstance=isinstance, callable=callable):
        self.result = []
        self.indent_with = indent_with
        self.add_line_information = add_line_information
        self.indentation = 0  # Current indentation level
        self.new_lines = 0  # Number of lines to insert before next code
        self.colinfo = 0, 0  # index in result of string containing linefeed, and
                             # position of last linefeed in that string
        AST = ast.AST

        visit = self.visit
        result = self.result
        append = result.append

        self.discard_numeric_delim_for_const = False
        self.preserve_quotes = False

        def write(*params):
            """ self.write is a closure for performance (to reduce the number
                of attribute lookups).
            """
            for item in params:
                if isinstance(item, AST):
                    visit(item)
                elif callable(item):
                    item()
                else:
                    if self.new_lines:
                        append('\n' * self.new_lines)
                        self.colinfo = len(result), 0
                        append(self.indent_with * self.indentation)
                        self.new_lines = 0
                    if item:
                        append(item)

        self.write = write

    def __getattr__(self, name, defaults=dict(keywords=(),
                    _pp=Precedence.highest).get):
        """ Get an attribute of the node.
            like dict.get (returns None if doesn't exist)
        """
        if not name.startswith('get_'):
            raise AttributeError
        geta = getattr
        shortname = name[4:]
        default = defaults(shortname)

        def getter(node):
            return geta(node, shortname, default)

        setattr(self, name, getter)
        return getter

    def delimit(self, *args):
        return Delimit(self, *args)

    def conditional_write(self, *stuff):
        if stuff[-1] is not None:
            self.write(*stuff)
            # Inform the caller that we wrote
            return True

    def newline(self, node=None, extra=0):
        self.new_lines = max(self.new_lines, 1 + extra)
        if node is not None and self.add_line_information:
            self.write('# line: %s' % node.lineno)
            self.new_lines = 1

    def else_body(self, elsewhat):
        if elsewhat:
            self.write(self.newline, 'else:')
            self.body(elsewhat)

    def body_or_else(self, node):
        self.body(node.body)
        self.else_body(node.orelse)

    def visit_arguments(self, node):
        want_comma = []

        def write_comma(add_first_comma=False):
            if add_first_comma:
                self.write(', ')
            else:
                if want_comma:
                    self.write(', ')
                else:
                    want_comma.append(True)

        def loop_args(args, defaults):
            set_precedence(Precedence.Comma, defaults)
            padding = [None] * (len(args) - len(defaults))
            for arg, default in zip(args, padding + defaults):
                if arg.type_comment:
                    self.newline()
                    self.indentation += 1
                    self.write(arg)
                    self.conditional_write('=', default)
                    self.conditional_write(lambda: write_comma(True), ' # type: ', arg.type_comment)
                    self.indentation -= 1
                    self.newline()
                else:
                    self.write(write_comma, arg)
                    self.conditional_write('=', default)

        posonlyargs = getattr(node, 'posonlyargs', [])
        offset = 0
        if posonlyargs:
            offset = max(0, len(node.defaults) - len(node.args))
            loop_args(posonlyargs, node.defaults[:offset])
            self.write(write_comma, '/')

        loop_args(node.args, node.defaults[offset:])
        self.conditional_write(write_comma, '*', node.vararg)

        kwonlyargs = self.get_kwonlyargs(node)
        if kwonlyargs:
            if node.vararg is None:
                self.write(write_comma, '*')
            loop_args(kwonlyargs, node.kw_defaults)
        self.conditional_write(write_comma, '**', node.kwarg)

    def statement(self, node, *params, **kw):
        self.newline(node)
        self.write(*params)

    def decorators(self, node, extra):
        self.newline(extra=extra)
        for decorator in node.decorator_list:
            self.statement(decorator, '@', decorator)

    def comma_list(self, items, trailing=False):
        set_precedence(Precedence.Comma, *items)
        for idx, item in enumerate(items):
            self.write(', ' if idx else '', item)
        self.write(',' if trailing else '')

    def type_params(self, node):
        if getattr(node, 'type_params', []):  # Python >= 3.12
            self.write('[')
            self.comma_list(node.type_params)
            self.write(']')

    # Statements

    def visit_Assign(self, node):
        set_precedence(node, node.value, *node.targets)
        self.newline(node)
        for target in node.targets:
            self.write(target, ' = ')
        self.visit(node.value)
        self.add_type_comment(node)

    def visit_AugAssign(self, node):
        set_precedence(node, node.value, node.target)
        self.statement(node, node.target, get_op_symbol(node.op, ' %s= '),
                       node.value)

    def visit_AnnAssign(self, node):
        set_precedence(node, node.target, node.annotation)
        set_precedence(Precedence.Comma, node.value)
        need_parens = isinstance(node.target, ast.Name) and not node.simple
        begin = '(' if need_parens else ''
        end = ')' if need_parens else ''
        self.statement(node, begin, node.target, end, ': ', node.annotation)
        self.conditional_write(' = ', node.value)

    def visit_ImportFrom(self, node):
        self.statement(node, 'from ', node.level * '.',
                       node.module or '', ' import ')
        self.comma_list(node.names)

    def visit_Import(self, node):
        self.statement(node, 'import ')
        self.comma_list(node.names)

    def visit_Expr(self, node):
        set_precedence(node, node.value)
        self.statement(node)
        self.generic_visit(node)

    def visit_TypeAlias(self, node):
        self.statement(node, 'type ', node.name)
        self.type_params(node)
        self.write(' = ')
        self.visit(node.value)

    def visit_TypeVar(self, node):
        self.write(node.name)
        if node.bound:
            self.write(': ', node.bound)

    def visit_TypeVarTuple(self, node):
        self.write('*')
        self.write(node.name)

    def visit_ParamSpec(self, node):
        self.write('**')
        self.write(node.name)

    def visit_FunctionDef(self, node, is_async=False):
        prefix = 'async ' if is_async else ''
        self.decorators(node, 1 if self.indentation else 2)
        self.statement(node, '%sdef %s' % (prefix, node.name))
        self.type_params(node)
        self.write('(')
        self.visit_arguments(node.args)
        self.write(')')
        self.conditional_write(' -> ', self.get_returns(node))
        self.write(':')
        self.add_type_comment(node)
        self.newline()
        self.body(node.body, is_docstring=True)
        if not self.indentation:
            self.newline(extra=2)

    # introduced in Python 3.5
    def visit_AsyncFunctionDef(self, node):
        self.visit_FunctionDef(node, is_async=True)

    def visit_ClassDef(self, node):
        have_args = []

        def paren_or_comma():
            if have_args:
                self.write(', ')
            else:
                have_args.append(True)
                self.write('(')

        self.decorators(node, 2)
        self.statement(node, 'class %s' % node.name)
        self.type_params(node)
        for base in node.bases:
            self.write(paren_or_comma, base)
        # keywords not available in early version
        for keyword in self.get_keywords(node):
            self.write(paren_or_comma, keyword.arg or '',
                       '=' if keyword.arg else '**', keyword.value)
        self.conditional_write(paren_or_comma, '*', self.get_starargs(node))
        self.conditional_write(paren_or_comma, '**', self.get_kwargs(node))
        self.write(have_args and '):' or ':')
        self.newline()
        self.body(node.body, is_docstring=True)
        if not self.indentation:
            self.newline(extra=2)

    def visit_If(self, node):
        set_precedence(node, node.test)
        self.statement(node, 'if ', node.test, ':')
        self.body(node.body)
        while True:
            else_ = node.orelse
            if len(else_) == 1 and isinstance(else_[0], ast.If):
                node = else_[0]
                set_precedence(node, node.test)
                self.write(self.newline, 'elif ', node.test, ':')
                self.body(node.body)
            else:
                self.else_body(else_)
                break

    def visit_For(self, node, is_async=False):
        set_precedence(node, node.target)
        prefix = 'async ' if is_async else ''
        self.statement(node, '%sfor ' % prefix,
                       node.target, ' in ', node.iter, ':')
        self.add_type_comment(node)
        self.body_or_else(node)

    # introduced in Python 3.5
    def visit_AsyncFor(self, node):
        self.visit_For(node, is_async=True)

    def visit_While(self, node):
        set_precedence(node, node.test)
        self.statement(node, 'while ', node.test, ':')
        self.body_or_else(node)

    def visit_With(self, node, is_async=False):
        prefix = 'async ' if is_async else ''
        self.statement(node, '%swith ' % prefix)
        self.comma_list(node.items)
        self.write(':')
        self.add_type_comment(node)
        self.body(node.body)

    # new for Python 3.5
    def visit_AsyncWith(self, node):
        self.visit_With(node, is_async=True)

    # new for Python 3.3
    def visit_withitem(self, node):
        self.write(node.context_expr)
        self.conditional_write(' as ', node.optional_vars)

    # deprecated in Python 3.8
    def visit_NameConstant(self, node):
        self.write(repr(node.value))

    def visit_Pass(self, node):
        self.statement(node, 'pass')

    def visit_Delete(self, node):
        self.statement(node, 'del ')
        self.comma_list(node.targets)

    def visit_TryExcept(self, node):
        self.statement(node, 'try:')
        self.body(node.body)
        self.write(*node.handlers)
        self.else_body(node.orelse)

    # new for Python 3.3
    def visit_Try(self, node):
        self.statement(node, 'try:')
        self.body(node.body)
        self.write(*node.handlers)
        self.else_body(node.orelse)
        if node.finalbody:
            self.statement(node, 'finally:')
            self.body(node.finalbody)

    # except* (introduced in Python 3.11)
    def visit_TryStar(self, node):
        self.statement(node, 'try:')
        self.body(node.body)
        for handler in node.handlers:
            self.visit_ExceptHandler(handler, star=True)
        self.else_body(node.orelse)
        if node.finalbody:
            self.statement(node, 'finally:')
            self.body(node.finalbody)

    def visit_ExceptHandler(self, node, star=False):
        self.statement(node, 'except')
        if star:
            self.write('*')
        if self.conditional_write(' ', node.type):
            self.conditional_write(' as ', node.name)
        self.write(':')
        self.body(node.body)

    def visit_TryFinally(self, node):
        self.statement(node, 'try:')
        self.body(node.body)
        self.statement(node, 'finally:')
        self.body(node.finalbody)

    def visit_Exec(self, node):
        dicts = node.globals, node.locals
        dicts = dicts[::-1] if dicts[0] is None else dicts
        self.statement(node, 'exec ', node.body)
        self.conditional_write(' in ', dicts[0])
        self.conditional_write(', ', dicts[1])

    def visit_Assert(self, node):
        set_precedence(node, node.test, node.msg)
        self.statement(node, 'assert ', node.test)
        self.conditional_write(', ', node.msg)

    def visit_Global(self, node):
        self.statement(node, 'global ', ', '.join(node.names))

    def visit_Nonlocal(self, node):
        self.statement(node, 'nonlocal ', ', '.join(node.names))

    def visit_Return(self, node):
        set_precedence(node, node.value)
        self.statement(node, 'return')
        self.conditional_write(' ', node.value)

    def visit_Break(self, node):
        self.statement(node, 'break')

    def visit_Continue(self, node):
        self.statement(node, 'continue')

    def visit_Raise(self, node):
        self.statement(node, 'raise')
        if self.conditional_write(' ', self.get_exc(node)):
            self.conditional_write(' from ', node.cause)

    # Match statement (introduced in Python 3.10)
    def visit_Match(self, node):
        self.discard_numeric_delim_for_const = True
        self.statement(node, 'match ', node.subject, ':')
        self.body(node.cases)
        self.discard_numeric_delim_for_const = False

    def visit_match_case(self, node):
        self.statement(node, 'case ', node.pattern)
        self.conditional_write(' if ', node.guard)
        self.write(':')
        self.body(node.body)

    def visit_MatchSequence(self, node):
        with self.delimit('[]'):
            self.comma_list(node.patterns)

    def visit_MatchValue(self, node):
        self.write(node.value)

    def visit_MatchSingleton(self, node):
        self.write(str(node.value))

    def visit_MatchStar(self, node):
        self.write('*', node.name or '_')

    def visit_MatchMapping(self, node):
        with self.delimit('{}'):
            for idx, (key, value) in enumerate(zip(node.keys, node.patterns)):
                if key:
                    set_precedence(Precedence.Comma, value)
                self.write(', ' if idx else '',
                           key if key else '',
                           ': ' if key else '**', value)
            if node.rest:
                if node.keys:
                    self.write(', ')
                self.write('**', node.rest)

    def visit_MatchAs(self, node):
        if not node.pattern:
            self.write(node.name or '_')
        else:
            self.write(node.pattern, ' as ', node.name)

    def visit_MatchOr(self, node):
        for idx, pattern in enumerate(node.patterns):
            self.write(' | ' if idx else '', pattern)

    def visit_MatchClass(self, node):
        write = self.write
        want_comma = []

        def write_comma():
            if want_comma:
                write(', ')
            else:
                want_comma.append(True)

        self.visit(node.cls)
        with self.delimit('()'):
            args = node.patterns
            for arg in args:
                write(write_comma, arg)

            kwd_attrs = node.kwd_attrs
            kwd_patterns = node.kwd_patterns

            for key, value in zip(kwd_attrs, kwd_patterns):
                write(write_comma, key, '=', value)

    # Expressions

    def visit_Attribute(self, node):
        self.write(node.value, '.', node.attr)

    def visit_Call(self, node, len=len):
        write = self.write
        want_comma = []

        def write_comma():
            if want_comma:
                write(', ')
            else:
                want_comma.append(True)

        args = node.args
        keywords = node.keywords
        starargs = self.get_starargs(node)
        kwargs = self.get_kwargs(node)
        numargs = len(args) + len(keywords)
        numargs += starargs is not None
        numargs += kwargs is not None
        p = Precedence.Comma if numargs > 1 else Precedence.call_one_arg
        set_precedence(p, *args)
        self.visit(node.func)
        write('(')
        for arg in args:
            write(write_comma, arg)

        set_precedence(Precedence.Comma,
            *(x.value for x in keywords if x.arg))
        for keyword in keywords:
            # a keyword.arg of None indicates dictionary unpacking
            # (Python >= 3.5)
            arg = keyword.arg or ''
            write(write_comma, arg, '=' if arg else '**', keyword.value)
        # 3.5 no longer has these
        self.conditional_write(write_comma, '*', starargs)
        self.conditional_write(write_comma, '**', kwargs)
        write(')')

    def visit_Name(self, node):
        self.write(node.id)

    # ast.Constant is new in Python 3.6 and it replaces ast.Bytes,
    # ast.Ellipsis, ast.NameConstant, ast.Num, ast.Str in Python 3.8
    def visit_Constant(self, node):
        value = node.value

        if isinstance(value, (int, float, complex)):
            with self.delimit(node) as delimiters:
                if self.discard_numeric_delim_for_const:
                    delimiters.discard = True
                self._handle_numeric_constant(value)
        elif isinstance(value, str):
            quote_char = '"' if self.preserve_quotes else None
            self._handle_string_constant(node, node.value, quote_preference=quote_char)
        elif value is Ellipsis:
            self.write('...')
        else:
            self.write(repr(value))

    def visit_JoinedStr(self, node):
        self._handle_string_constant(node, None, is_joined=True)

    def process_fstring_nodes(self, node):
        for value in node.values:
            if isinstance(value, ast.Str):
                content = value.s
                if '\\' in content:
                    content = content.replace('\\', '\\\\')
                content = content.replace('{', '{{').replace('}', '}}')
                result_chars = []
                for c in content:
                    if c == '\n':
                        result_chars.append('\\n')
                    elif c == '\t':
                        result_chars.append('\\t')
                    elif c == '\r':
                        result_chars.append('\\r')
                    elif c == '\0':
                        result_chars.append('\\0')
                    elif c == '\a':
                        result_chars.append('\\a')
                    elif c == '\b':
                        result_chars.append('\\b')
                    elif c == '\f':
                        result_chars.append('\\f')
                    elif c == '\v':
                        result_chars.append('\\v')
                    elif ord(c) < 32 or ord(c) == 127:
                        result_chars.append(f'\\x{ord(c):02x}')
                    else:
                        result_chars.append(c)
                content = ''.join(result_chars)
                self.write(content)
            elif isinstance(value, ast.FormattedValue):
                self.write('{')
                set_precedence(value, value.value)
                self.visit(value.value)
                if value.conversion != -1:
                    self.write('!%s' % chr(value.conversion))
                if value.format_spec is not None:
                    self.write(':')
                    self.process_fstring_nodes(value.format_spec)
                self.write('}')
            elif isinstance(value, ast.Constant):
                content = str(value.value)
                result_chars = []
                for c in content:
                    if c == '\n':
                        result_chars.append('\\n')
                    elif c == '\t':
                        result_chars.append('\\t')
                    elif c == '\r':
                        result_chars.append('\\r')
                    elif c == '\0':
                        result_chars.append('\\0')
                    elif c == '\a':
                        result_chars.append('\\a')
                    elif c == '\b':
                        result_chars.append('\\b')
                    elif c == '\f':
                        result_chars.append('\\f')
                    elif c == '\v':
                        result_chars.append('\\v')
                    elif ord(c) < 32 or ord(c) == 127:
                        result_chars.append(f'\\x{ord(c):02x}')
                    else:
                        result_chars.append(c)
                content = ''.join(result_chars)
                self.write(content)

    def _analyze_string_quotes(self, node, value, is_joined):
        """First pass: Analyze string content for quotes"""
        has_single = False
        has_double = False

        if is_joined:
            # For f-strings, analyze expressions
            values = node.values if isinstance(node.values, list) else []
            for value in values:
                if isinstance(value, ast.FormattedValue):
                    # Capture output to analyze
                    expr_start = len(self.result)
                    self.visit(value.value)
                    expr_text = ''.join(self.result[expr_start:])
                    del self.result[expr_start:]

                    has_single = has_single or ("'" in expr_text)
                    has_double = has_double or ('"' in expr_text)

                    if value.format_spec:
                        # Also check format spec for quotes
                        spec_start = len(self.result)
                        self.visit(value.format_spec)
                        spec_text = ''.join(self.result[spec_start:])
                        del self.result[spec_start:]

                        has_single = has_single or ("'" in spec_text)
                        has_double = has_double or ('"' in spec_text)
        else:
            # Regular string
            if value is not None:
                has_single = "'" in value
                has_double = '"' in value

        return has_single, has_double

    def _determine_quote_style(self, has_single, has_double):
        """Second pass: Determine quote style based on analysis"""
        if has_single and has_double:
            return '"""'
        elif has_single:
            return '"'
        elif has_double:
            return "'"
        else:
            return "'"  # Default to single quotes when no quotes present

    def body(self, statements, is_docstring=False):
        """Handle body of functions, classes, modules etc."""
        if is_docstring and statements and isinstance(statements[0], ast.Expr) and \
           isinstance(statements[0].value, ast.Constant) and \
           isinstance(statements[0].value.value, str):
            # Handle docstring
            self.indentation += 1
            self._handle_docstring(statements[0].value.value)
            self.write(*statements[1:])  # Handle remaining statements normally
            self.indentation -= 1
        else:
            # No docstring - handle all statements normally
            self.indentation += 1
            self.write(*statements)
            self.indentation -= 1

    def visit_Module(self, node):
        """Handle module nodes, including docstrings."""
        if node.body and isinstance(node.body[0], ast.Expr) and \
           isinstance(node.body[0].value, ast.Constant) and \
           isinstance(node.body[0].value.value, str):
            # Module-level docstring
            docstring = node.body[0].value.value
            self._handle_docstring(docstring)
            self.write(*node.body[1:])
        else:
            self.write(*node.body)

    def _handle_docstring(self, value):
        """Convert raw docstring to regular docstring with proper escaping."""
        content = ""
        i = 0
        while i < len(value):
            if value[i] == '\\':
                content += '\\\\'  # Double the backslash
                if i + 1 < len(value):
                    if value[i + 1] == '\\':
                        content += '\\\\'  # Double escape for literal backslash
                    else:
                        content += value[i + 1]  # Normal escape for other chars
                i += 2
            else:
                content += value[i]
                i += 1

        # Choose quote style to avoid issues with trailing quotes
        if content.endswith('"'):
            if "'''" not in content:
                self.write("'''" + content + "'''")
            else:
                # Content has ''' and ends with " — escape the trailing "
                content = content[:-1] + '\\"'
                self.write('"""' + content + '"""')
        else:
            self.write('"""' + content + '"""')

    def _handle_string_constant(self, node, value, is_joined=False, is_docstring=False, quote_preference=None):
        """Handle string constants and preserve escape sequences."""
        self.write('')  # Process any pending newlines

        if is_docstring:
            self._handle_docstring(value)
            return

        if is_joined:
            self.preserve_quotes = True
            index = len(self.result)
            self.process_fstring_nodes(node)
            self.preserve_quotes = False
            fstring_content = ''.join(self.result[index:])
            del self.result[index:]

            # Convert actual newlines back to \n escape sequences
            fstring_content = fstring_content.replace('\n', '\\n')

            has_single = "'" in fstring_content
            has_double = '"' in fstring_content
            if has_single and has_double:
                # Both quote types present — use triple quotes
                if "'''" not in fstring_content:
                    quote = "'''"
                elif '"""' not in fstring_content:
                    quote = '"""'
                else:
                    quote = '"""'
                    fstring_content = fstring_content.replace('"""', '\\"\\"\\"')
                # Handle trailing quote matching delimiter
                if fstring_content and fstring_content[-1] == quote[0]:
                    fstring_content = fstring_content[:-1] + '\\' + fstring_content[-1]
                self.write('f' + quote + fstring_content + quote)
            elif has_single:
                self.write('f"' + fstring_content + '"')
            else:
                self.write("f'" + fstring_content + "'")
        else:
            # Regular strings
            if value is not None:
                string_repr = repr(value)
                # If we have a kind (like 'u' for unicode), prepend it
                kind = getattr(node, 'kind', None)
                if kind:
                    # Remove the quote at the start, add kind, then put quote back
                    self.write(kind + string_repr[0] + string_repr[1:])
                else:
                    self.write(string_repr)
            else:
                self.write("''")

    # deprecated in Python 3.8
    def visit_Str(self, node):
        self._handle_string_constant(node, node.s)

    # deprecated in Python 3.8
    def visit_Bytes(self, node):
        self.write(repr(node.s))

    def _handle_numeric_constant(self, value):
        x = value

        def part(p, imaginary):
            # Represent infinity as 1e1000 and NaN as 1e1000-1e1000.
            s = 'j' if imaginary else ''
            try:
                if math.isinf(p):
                    if p < 0:
                        return '-1e1000' + s
                    return '1e1000' + s
                if math.isnan(p):
                    return '(1e1000%s-1e1000%s)' % (s, s)
            except OverflowError:
                # math.isinf will raise this when given an integer
                # that's too large to convert to a float.
                pass
            return repr(p) + s

        real = part(x.real if isinstance(x, complex) else x, imaginary=False)
        if isinstance(x, complex):
            imag = part(x.imag, imaginary=True)
            if x.real == 0:
                s = imag
            elif x.imag == 0:
                s = '(%s+0j)' % real
            else:
                # x has nonzero real and imaginary parts.
                s = '(%s%s%s)' % (real, ['+', ''][imag.startswith('-')], imag)
        else:
            s = real
        self.write(s)

    def visit_Num(self, node):
        with self.delimit(node):
            self._handle_numeric_constant(node.n)

    def visit_Tuple(self, node):
        with self.delimit(node) as delimiters:
            # Two things are special about tuples:
            #   1) We cannot discard the enclosing parentheses if empty
            #   2) We need the trailing comma if only one item
            elts = node.elts
            delimiters.discard = delimiters.discard and elts
            self.comma_list(elts, len(elts) == 1)

    def visit_List(self, node):
        with self.delimit('[]'):
            self.comma_list(node.elts)

    def visit_Set(self, node):
        if node.elts:
            with self.delimit('{}'):
                self.comma_list(node.elts)
        else:
            # If we tried to use "{}" to represent an empty set, it would be
            # interpreted as an empty dictionary. We can't use "set()" either
            # because the name "set" might be rebound.
            self.write('{1}.__class__()')

    def visit_Dict(self, node):
        with self.delimit('{}'):
            for idx, (key, value) in enumerate(zip(node.keys, node.values)):
                if key:
                    set_precedence(Precedence.Comma, key)
                    set_precedence(Precedence.Comma, value)
                self.write(', ' if idx else '',
                           key if key else '',
                           ': ' if key else '**', value)

    def visit_BinOp(self, node):
        op, left, right = node.op, node.left, node.right
        with self.delimit(node, op) as delimiters:
            ispow = isinstance(op, ast.Pow)
            p = delimiters.p
            set_precedence((Precedence.Pow + 1) if ispow else p, left)
            set_precedence(Precedence.PowRHS if ispow else (p + 1), right)
            self.write(left, get_op_symbol(op, ' %s '), right)

    def visit_BoolOp(self, node):
        with self.delimit(node, node.op) as delimiters:
            op = get_op_symbol(node.op, ' %s ')
            set_precedence(delimiters.p + 1, *node.values)
            for idx, value in enumerate(node.values):
                self.write(idx and op or '', value)

    def visit_Compare(self, node):
        with self.delimit(node, node.ops[0]) as delimiters:
            if self.discard_numeric_delim_for_const:
                delimiters.discard = True
            set_precedence(delimiters.p + 1, node.left, *node.comparators)
            self.visit(node.left)
            for op, right in zip(node.ops, node.comparators):
                self.write(get_op_symbol(op, ' %s '), right)

    # assignment expressions; new for Python 3.8
    def visit_NamedExpr(self, node):
        with self.delimit(node) as delimiters:
            p = delimiters.p
            set_precedence(p, node.target)
            set_precedence(p + 1, node.value)
            # Python is picky about delimiters for assignment
            # expressions: it requires at least one pair in any
            # statement that uses an assignment expression, even
            # when not necessary according to the precedence
            # rules. We address this with the kludge of forcing a
            # pair of parentheses around every assignment
            # expression.
            delimiters.discard = False
            self.write(node.target, ' := ', node.value)

    def visit_UnaryOp(self, node):
        with self.delimit(node, node.op) as delimiters:
            set_precedence(delimiters.p, node.operand)
            # TODO: Remove this.
            # In Python 2.x, a unary negative of a literal
            # number is merged into the number itself.  This
            # bit of ugliness means it is useful to know
            # what the parent operation was...
            node.operand._p_op = node.op
            sym = get_op_symbol(node.op)
            self.write(sym, ' ' if sym.isalpha() else '', node.operand)

    def visit_Subscript(self, node):
        set_precedence(node, node.slice)
        self.write(node.value, '[', node.slice, ']')

    def visit_Slice(self, node):
        set_precedence(node, node.lower, node.upper, node.step)
        self.conditional_write(node.lower)
        self.write(':')
        self.conditional_write(node.upper)
        if node.step is not None:
            self.write(':')
            if not (isinstance(node.step, ast.Name) and
                    node.step.id == 'None'):
                self.visit(node.step)

    def visit_Index(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.value)
            self.visit(node.value)

    def visit_ExtSlice(self, node):
        dims = node.dims
        set_precedence(node, *dims)
        self.comma_list(dims, len(dims) == 1)

    def visit_Yield(self, node):
        with self.delimit(node):
            set_precedence(get_op_precedence(node) + 1, node.value)
            self.write('yield')
            self.conditional_write(' ', node.value)

    # new for Python 3.3
    def visit_YieldFrom(self, node):
        with self.delimit(node):
            self.write('yield from ', node.value)

    # new for Python 3.5
    def visit_Await(self, node):
        with self.delimit(node):
            self.write('await ', node.value)

    def visit_Lambda(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p, node.body)
            self.write('lambda ')
            self.visit_arguments(node.args)
            self.write(': ', node.body)

    def visit_Ellipsis(self, node):
        self.write('...')

    def visit_ListComp(self, node):
        with self.delimit('[]'):
            self.write(node.elt, *node.generators)

    def visit_GeneratorExp(self, node):
        with self.delimit(node) as delimiters:
            if delimiters.pp == Precedence.call_one_arg:
                delimiters.discard = True
            set_precedence(Precedence.Comma, node.elt)
            self.write(node.elt, *node.generators)

    def visit_SetComp(self, node):
        with self.delimit('{}'):
            self.write(node.elt, *node.generators)

    def visit_DictComp(self, node):
        with self.delimit('{}'):
            self.write(node.key, ': ', node.value, *node.generators)

    def visit_IfExp(self, node):
        with self.delimit(node) as delimiters:
            set_precedence(delimiters.p + 1, node.body, node.test)
            set_precedence(delimiters.p, node.orelse)
            self.write(node.body, ' if ', node.test, ' else ', node.orelse)

    def visit_Starred(self, node):
        self.write('*', node.value)


    visit_Interactive = visit_Module

    def visit_Expression(self, node):
        self.visit(node.body)

    def visit_arg(self, node):
        self.write(node.arg)
        self.conditional_write(': ', node.annotation)

    def visit_alias(self, node):
        self.write(node.name)
        self.conditional_write(' as ', node.asname)

    def visit_comprehension(self, node):
        set_precedence(node, node.iter, *node.ifs)
        set_precedence(Precedence.comprehension_target, node.target)
        stmt = ' async for ' if self.get_is_async(node) else ' for '
        self.write(stmt, node.target, ' in ', node.iter)
        for if_ in node.ifs:
            self.write(' if ', if_)

    # new for Python 3.8
    def add_type_comment(self, node):
        self.conditional_write('  # type: ', node.type_comment)
